/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use std::collections::LinkedList;
use std::ops::Deref;

use smallvec::Array;

use wavr_audio_buffer::AudioBuffer;
use wavr_meter::{WavrMeter, WavrMeterData};

use crate::context::AudioContext;
use crate::effect::Effect;

pub struct RackEffect {
    effect: Box<dyn Effect>,
    meter: Option<WavrMeter>,
    enabled: bool,
}

pub struct Rack {
    input_meter: Option<WavrMeter>,
    effects: LinkedList<RackEffect>,
    output_meter: Option<WavrMeter>,
}

impl RackEffect {
    pub fn new<E: 'static + Effect>(effect: E) -> Self {
        Self {
            effect: Box::new(effect),
            meter: None,
            enabled: true,
        }
    }

    pub fn get_meter_data(&self) -> Option<WavrMeterData> {
        self.meter.as_ref().map(|m| m.get_values())
    }

    pub fn enabled(&self) -> bool {
        self.enabled
    }

    pub fn disable(&mut self) {
        self.enabled = false;
    }

    pub fn enable(&mut self) {
        self.enabled = true;
    }

    pub fn toggle(&mut self) {
        self.enabled = !self.enabled;
    }
}

impl Effect for RackEffect {
    fn process(&mut self, context: &AudioContext, data: &mut AudioBuffer) {
        self.effect.process(context, data);
        let meter = self.meter.get_or_insert_with(|| {
            WavrMeter::new(context.channel_count as u32, context.sample_rate as u32)
        });
        meter.add_samples(data);
    }
}

impl Rack {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn push_effect<E: 'static + Effect>(&mut self, effect: E) {
        self.effects.push_back(RackEffect::new(effect));
    }

    pub fn insert_effect<E: 'static + Effect>(&mut self, pos: usize, effect: E) {
        let mut after = self.effects.split_off(pos);
        after.push_front(RackEffect::new(effect));
        self.effects.append(&mut after);
    }

    pub fn remove_effect(&mut self, pos: usize) {
        let mut after = self.effects.split_off(pos);
        after.pop_front();
        self.effects.append(&mut after);
    }

    pub fn reorder_effect(&mut self, pos_src: usize, pos_dest: usize) {
        let mut after = self.effects.split_off(pos_src);
        let effect = after.pop_front().unwrap();
        self.effects.append(&mut after);

        let mut after = self.effects.split_off(pos_dest);
        after.push_front(effect);
        self.effects.append(&mut after);
    }

    pub fn get_input_meter_data(&self) -> Option<WavrMeterData> {
        self.input_meter.as_ref().map(|m| m.get_values())
    }

    pub fn get_output_meter_data(&self) -> Option<WavrMeterData> {
        self.output_meter.as_ref().map(|m| m.get_values())
    }
}

impl Default for Rack {
    fn default() -> Self {
        Self {
            input_meter: None,
            effects: LinkedList::new(),
            output_meter: None,
        }
    }
}

impl Effect for Rack {
    fn process(&mut self, context: &AudioContext, data: &mut AudioBuffer) {
        if !context.is_playing() {
            return;
        }

        let input_meter = self.input_meter.get_or_insert_with(|| {
            WavrMeter::new(context.channel_count as u32, context.sample_rate as u32)
        });
        let output_meter = self.output_meter.get_or_insert_with(|| {
            WavrMeter::new(context.channel_count as u32, context.sample_rate as u32)
        });
        input_meter.add_samples(data);
        if !self.effects.is_empty() {
            for effect in self.effects.iter_mut().filter(|e| e.enabled) {
                effect.process(context, data);
            }
        }
        output_meter.add_samples(data);
    }
}
