/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use wavr_audio_buffer::AudioBuffer;

use crate::{AudioContext, AudioContextState, Effect, Rack};

pub struct AudioEngine {
    context: AudioContext,
    rack: Rack,
}

impl AudioEngine {
    pub fn new(sample_rate: u64, channel_count: u8) -> Self {
        let context = AudioContext::new(sample_rate, channel_count);
        Self {
            context,
            rack: Rack::new(),
        }
    }

    pub fn fill_interleaved(&mut self, input: &mut [f64]) {
        let mut buffer = AudioBuffer::new(self.context.channel_count as usize, input);
        self.fill_buffer(&mut buffer);
        let interleaved = buffer.interleave();
        unsafe {
            std::ptr::copy_nonoverlapping(
                interleaved.as_ptr(),
                input.as_mut_ptr(),
                interleaved.len(),
            )
        }
    }

    pub fn fill_buffer(&mut self, input: &mut AudioBuffer) {
        self.rack.process(&self.context, input);
        self.context.add_sample_cycle(input);
    }

    pub fn get_rack(&self) -> &Rack {
        &self.rack
    }

    pub fn get_rack_mut(&mut self) -> &mut Rack {
        &mut self.rack
    }

    pub fn get_context(&self) -> &AudioContext {
        &self.context
    }

    pub fn set_context_state(&mut self, state: AudioContextState) {
        self.context.state = state;
    }
}

fn fill<T: Copy>(vec: &mut Vec<T>, value: T) {
    vec.iter_mut().for_each(|v| *v = value);
}
