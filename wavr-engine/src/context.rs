/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */
//! Module implementing the `AudioContext` structure, keeping track of the state
//! of the processing and timestamp of the current audio frame.
//!
//! You will most likely not need to care about its lifetime, only its usage
//! (unless you're using it within your own audio engine).

use std::time::Duration;

use wavr_audio_buffer::AudioBuffer;

/// Enumeration of the state of the `AudioContext`. By default,
/// `AudioContextState` is created paused, which may indicate different
/// behaviors depending on the backing audio engine, but for the Wavr Rack it
/// means that all effects are bypassed and the output is muted. This is useful
/// for the application to stop processing audio entirely when no sound is
/// playing (ie. no audio playback and not monitoring the audio input).
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum AudioContextState {
    Paused,
    Playing,
    Offline,
}

/// The AudioContext structure holds information about the state of processing
/// (see [`AudioContextState`](struct.AudioContextState.html)), and timestamp of the
/// current audio block.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct AudioContext {
    /// Sample rate in Hertz (or samples per second).
    pub sample_rate: u64,
    /// Number of channels the engine supports. Note that this means that the
    /// engine has the same number or input channels as it has output channels.
    pub channel_count: u8,
    /// Tracks the position of the first sample of the current audio frame. Used
    /// to generate [`Duration`](std::time::Duration) values, keeping the
    /// timestamping stable and free of floating-point rounding errors.
    pub current_sample: usize,
    /// State of the audio context. See
    /// [`AudioContextState`](struct.AudioContextState.html).
    pub state: AudioContextState,
}

impl AudioContext {
    /// Create a new audio context. By default the context's timestamp is reset
    /// and the audio context state is set to
    /// [`Paused`](struct.AudioContextState.html#Paused).
    pub fn new(sample_rate: u64, channel_count: u8) -> Self {
        Self {
            sample_rate,
            channel_count,
            current_sample: 0,
            state: AudioContextState::Paused,
        }
    }

    /// Returns the position of this `AudioContext` as a
    /// [`Duration`](std::time::Duration).
    pub fn timestamp(&self) -> Duration {
        // TODO: Switch to integer arithmetic, creating durations from
        // nanoseconds
        let seconds = self.current_sample as f64 / self.sample_rate as f64;
        Duration::from_secs_f64(seconds)
    }

    /// Returns the position of this `AudioContext`, offset by an amount, as a
    /// [`Duration`](std::time::Duration). Useful when processing the audio
    /// frame sample-by-sample to get a precise timestamp (ie. generating
    /// oscillators).
    pub fn timestamp_offset(&self, offset: usize) -> Duration {
        // TODO: Switch to integer arithmetic, creating durations from
        // nanoseconds
        let seconds = (self.current_sample + offset) as f64 / self.sample_rate as f64;
        Duration::from_secs_f64(seconds)
    }

    /// Mutates the `AudioContext` by adding the length of the buffer to the
    /// timestamp.
    pub fn add_sample_cycle(&mut self, buffer: &AudioBuffer) {
        self.current_sample += buffer.buffer_size();
    }

    /// Returns whether the `AudioContext` is in a playing state.
    pub fn is_playing(&self) -> bool {
        match self.state {
            AudioContextState::Playing | AudioContextState::Offline => true,
            _ => false,
        }
    }
}
