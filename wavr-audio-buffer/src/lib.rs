/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use std::borrow::{Borrow, BorrowMut};
use std::cmp::Ordering;
use std::ops::{Bound, Deref, Index, IndexMut, Range, RangeBounds};

use smallvec::{Array, SmallVec};

#[derive(Clone, Debug, PartialEq)]
pub struct AudioBuffer {
    audio_data: SmallVec<[Vec<f64>; 16]>,
    buffer_size: usize,
}

#[derive(Clone, Debug, PartialEq)]
pub struct Iter<'a> {
    buffer: &'a AudioBuffer,
    position: usize,
}

impl AudioBuffer {
    pub fn new(channels: usize, data: &[f64]) -> Self {
        let mut this = unsafe { Self::unitialized(channels, data.len() / channels) };

        for (i, v) in data.iter().cloned().enumerate() {
            this.audio_data[i % channels][i / channels] = v;
        }

        this
    }

    pub fn zeroed(channels: usize, buffer_size: usize) -> Self {
        Self {
            audio_data: SmallVec::from_vec(vec![vec![0.0; buffer_size]; channels]),
            buffer_size,
        }
    }

    pub fn empty(channels: usize) -> Self {
        Self {
            audio_data: SmallVec::from_vec(vec![vec![]; channels]),
            buffer_size: 0,
        }
    }

    pub unsafe fn unitialized(channels: usize, buffer_size: usize) -> Self {
        Self {
            audio_data: SmallVec::from_vec(vec![
                {
                    let mut v = Vec::with_capacity(buffer_size);
                    v.set_len(buffer_size);
                    v
                };
                channels
            ]),
            buffer_size,
        }
    }

    #[inline]
    pub fn channels(&self) -> usize {
        self.audio_data.len()
    }

    #[inline]
    pub fn buffer_size(&self) -> usize {
        self.buffer_size
    }

    pub fn with_channels(mut self, channels: usize) -> Self {
        match self.channels().cmp(&channels) {
            Ordering::Less => {
                for _ in 0..(channels - self.channels()) {
                    self.audio_data.push(vec![0.0; self.buffer_size]);
                }
                self
            }
            Ordering::Greater => {
                for _ in 0..(self.channels() - channels) {
                    self.audio_data.pop();
                }
                self
            }
            Ordering::Equal => self,
        }
    }

    pub fn channel(&self, channel: usize) -> Option<&[f64]> {
        if channel < self.audio_data.len() {
            Some(self.audio_data[channel].borrow())
        } else {
            None
        }
    }

    pub fn channel_mut(&mut self, channel: usize) -> Option<&mut [f64]> {
        if channel < self.audio_data.len() {
            Some(self.audio_data[channel].borrow_mut())
        } else {
            None
        }
    }

    pub fn sample(&self, channel: usize, position: usize) -> Option<f64> {
        if channel < self.channels() && position < self.buffer_size {
            Some(self.audio_data[channel][position])
        } else {
            None
        }
    }

    pub fn sample_mut(&mut self, channel: usize, position: usize) -> Option<&mut f64> {
        self.audio_data
            .get_mut(channel)
            .and_then(|v| v.get_mut(position))
    }

    pub fn apply_gain(&mut self, gain: f64) {
        for ch in &mut self.audio_data {
            ch.iter_mut().for_each(|v| *v *= gain);
        }
    }

    pub unsafe fn copy_interleaved(&mut self, slice: &[f64], position: usize) {
        let inner = Self::new(self.channels(), slice);
        for idx in 0..self.channels() {
            let src_ptr = inner[idx].as_ptr();
            let dst_ptr = self.audio_data[idx].as_mut_ptr().add(position);
            std::ptr::copy_nonoverlapping(src_ptr, dst_ptr, inner.buffer_size);
        }
    }

    pub fn copy_slice(&self, range: Range<usize>) -> Self {
        if range.start >= range.end {
            Self::empty(self.channels())
        } else {
            let range_len = range.end - range.start;
            let audio_data = (0..self.channels())
                .map(move |i| self.audio_data[i][range.clone()].to_vec())
                .collect();
            Self {
                audio_data,
                buffer_size: range_len,
            }
        }
    }

    pub fn interleave(self) -> Vec<f64> {
        let channels = self.channels();
        let out_size = channels * self.buffer_size;
        (0..out_size)
            .map(|i| self.audio_data[i % channels][i / channels])
            .collect()
    }

    pub fn iter(&self) -> Iter {
        Iter {
            buffer: self,
            position: 0,
        }
    }
}

impl Index<usize> for AudioBuffer {
    type Output = [f64];

    fn index(&self, channel: usize) -> &Self::Output {
        self.channel(channel).unwrap()
    }
}

impl Index<(usize, usize)> for AudioBuffer {
    type Output = f64;

    fn index(&self, (channel, position): (usize, usize)) -> &Self::Output {
        &self.audio_data[channel][position]
    }
}

impl IndexMut<usize> for AudioBuffer {
    fn index_mut(&mut self, channel: usize) -> &mut Self::Output {
        self.channel_mut(channel).unwrap()
    }
}

impl IndexMut<(usize, usize)> for AudioBuffer {
    fn index_mut(&mut self, (channel, position): (usize, usize)) -> &mut Self::Output {
        &mut self.audio_data[channel][position]
    }
}

impl Into<Vec<f64>> for AudioBuffer {
    fn into(self) -> Vec<f64> {
        self.interleave()
    }
}

impl<'a> Iterator for Iter<'a> {
    type Item = &'a [f64];

    fn next(&mut self) -> Option<Self::Item> {
        self.buffer.channel({
            let pos = self.position;
            self.position += 1;
            pos
        })
    }
}
