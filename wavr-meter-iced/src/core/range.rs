/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use num::Float;

#[derive(Copy, Clone, Debug)]
pub struct Range<F> {
    pub min: F,
    pub max: F,
}

impl<F: Float> Range<F> {
    pub fn range(&self) -> F {
        self.max - self.min
    }

    pub fn map(&self, x: F) -> F {
        (x - self.min) / self.range()
    }

    pub fn unmap(&self, x: F) -> F {
        self.min + x * self.range()
    }

    pub fn linspace(&self, count: F) -> Vec<(F, F)> {
        let icount = count.ceil() as usize;
        let step = F::one() / count;
        let mut cur = F::zero();
        let mut res = Vec::with_capacity(icount);
        for _ in 0..icount {
            res.push((cur, self.unmap(cur)));
            cur = cur + step;
        }

        res
    }
}

impl<F: Float> Default for Range<F> {
    fn default() -> Self {
        Self {
            min: F::zero(),
            max: F::one(),
        }
    }
}
