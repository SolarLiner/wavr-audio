/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use async_std::stream::IntoStream;
use async_std::sync::{channel, Receiver};
use cpal::traits::{DeviceTrait, EventLoopTrait, HostTrait};
use cpal::{Sample, StreamData, UnknownTypeInputBuffer};
use iced::{Application, Element, Settings};
use iced_native::{Column, Command, Subscription, Text};

use wavr_meter::{group_interleaved_channels, PeakMeter, WavrMeter, WavrMeterData};
use wavr_meter_iced::Meter;

mod recipes;

struct MetersApp {
    meters: Option<WavrMeter>,
    is_error: bool,
}

impl Application for MetersApp {
    type Executor = iced_futures::executor::AsyncStd;
    type Message = recipes::cpal::Data;
    type Flags = Option<Receiver<WavrMeterData>>;

    fn new(flags: Self::Flags) -> (Self, Command<Self::Message>) {
        (
            Self {
                meters: None,
                is_error: false,
            },
            Command::none(),
        )
    }

    fn title(&self) -> String {
        "Wavr Meter".to_string()
    }

    fn update(&mut self, message: Self::Message) -> Command<Self::Message> {
        use recipes::cpal::Data;
        match message {
            Data::Format(format) => {
                self.meters = Some(WavrMeter::new(format.channels as u32, format.sample_rate.0))
            }
            Data::Data(data) => {
                if let Some(meters) = self.meters.as_mut() {
                    meters.add_samples(&data);
                }
            }
            Data::Error => self.is_error = true,
        }
        Command::none()
    }

    fn subscription(&self) -> Subscription<Self::Message> {
        use recipes::cpal::*;
        default_stream()
    }

    fn view(&mut self) -> Element<'_, Self::Message> {
        if self.is_error {
            Text::new("An audio error occured. :<").into()
        } else {
            if let Some(data) = self.meters.as_mut().map(|m| m.get_values()) {
                Column::with_children(
                    data.peak
                        .iter()
                        .map(|val| Meter::new(val.into(), data.loudness).into())
                        .collect(),
                )
                .spacing(10)
                .into()
            } else {
                Text::new("No data yet").into()
            }
        }
    }
}

fn main() {
    MetersApp::run(Settings::default())
}
