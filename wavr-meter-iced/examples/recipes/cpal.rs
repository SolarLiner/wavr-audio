/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use std::hash::{Hash, Hasher};
use std::thread::JoinHandle;

use async_std::sync::channel;
use async_std::sync::Receiver;
use cpal::traits::{DeviceTrait, EventLoopTrait, HostTrait};
use cpal::{EventLoop, Sample, StreamData, UnknownTypeInputBuffer};
use iced_futures::BoxStream;

use wavr_meter::WavrMeter;

pub fn default_stream() -> iced::Subscription<Data> {
    iced::Subscription::from_recipe(CpalStream)
}

pub struct CpalStream;

impl<'a, H: Hasher, I> iced_native::subscription::Recipe<H, I> for CpalStream {
    type Output = Data;

    fn hash(&self, state: &mut H) {
        use std::hash::Hash;

        std::any::TypeId::of::<Self>().hash(state);
    }

    fn stream(self: Box<Self>, input: BoxStream<I>) -> BoxStream<Self::Output> {
        Box::pin(iced::futures::stream::unfold(
            State::Ready,
            |state| async move {
                match state {
                    State::Ready => {
                        let host = cpal::default_host();
                        let event_loop = host.event_loop();
                        if let Some(device) = host.default_input_device() {
                            if let Ok(format) = device.default_input_format() {
                                Some((
                                    Data::Format(format.clone()),
                                    State::Armed {
                                        host,
                                        event_loop,
                                        device,
                                        format,
                                    },
                                ))
                            } else {
                                Some((Data::Error, State::Done))
                            }
                        } else {
                            Some((Data::Error, State::Done))
                        }
                    }
                    State::Armed {
                        host,
                        event_loop,
                        device,
                        format,
                    } => {
                        let (tx, mut rx) = channel::<Vec<f64>>(16);
                        let handle = std::thread::spawn(move || {
                            let stream_id =
                                EventLoop::build_input_stream(&event_loop, &device, &format)
                                    .unwrap();
                            event_loop
                                .play_stream(stream_id)
                                .expect("failed to start input stream");
                            event_loop.run(move |_id, result| {
                                let data = match result {
                                    Ok(data) => data,
                                    Err(err) => {
                                        eprintln!("An error occurred on stream: {:?}", err);
                                        return;
                                    }
                                };

                                let buffer: Vec<f64> = match data {
                                    StreamData::Input {
                                        buffer: UnknownTypeInputBuffer::U16(buffer),
                                    } => buffer
                                        .iter()
                                        .cloned()
                                        .map(|v: u16| v.to_f32() as f64)
                                        .collect(),
                                    StreamData::Input {
                                        buffer: UnknownTypeInputBuffer::I16(buffer),
                                    } => buffer
                                        .iter()
                                        .cloned()
                                        .map(|v: i16| v.to_f32() as f64)
                                        .collect(),
                                    StreamData::Input {
                                        buffer: UnknownTypeInputBuffer::F32(buffer),
                                    } => buffer.iter().cloned().map(|v: f32| v as f64).collect(),
                                    _ => unreachable!(),
                                };
                                async_std::task::block_on(tx.send(buffer));
                            });
                        });

                        if let Ok(buffer) = rx.recv().await {
                            Some((Data::Data(buffer), State::Listening(handle, rx)))
                        } else {
                            Some((Data::Error, State::Listening(handle, rx)))
                        }
                    }
                    State::Listening(handle, mut rx) => {
                        if let Ok(buffer) = rx.recv().await {
                            Some((Data::Data(buffer), State::Listening(handle, rx)))
                        } else {
                            Some((Data::Error, State::Listening(handle, rx)))
                        }
                    }
                    State::Done => None,
                }
            },
        ))
    }
}

#[derive(Debug, Clone)]
pub enum Data {
    Format(cpal::Format),
    Data(Vec<f64>),
    Error,
}

pub enum State {
    Ready,
    Armed {
        host: cpal::Host,
        event_loop: cpal::EventLoop,
        device: cpal::Device,
        format: cpal::Format,
    },
    Listening(JoinHandle<()>, Receiver<Vec<f64>>),
    Done,
}
