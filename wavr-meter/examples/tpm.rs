/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use std::sync::mpsc::sync_channel;
use std::time::Duration;

use cpal::traits::{DeviceTrait, EventLoopTrait, HostTrait};
use cpal::{Sample, StreamData, UnknownTypeInputBuffer};
use pbr::{MultiBar, ProgressBar};
use smallvec::SmallVec;

use wavr_meter::decibel::{Decibel, Linear, LUFS};
use wavr_meter::{EBUMeter, PeakMeter};

fn main() {
    let (tx, rx) = sync_channel::<SmallVec<[Linear; 16]>>(16);
    let host = cpal::default_host();
    let event_loop = host.event_loop();
    let device = host
        .default_input_device()
        .expect("no output device available");
    let format = device
        .default_input_format()
        .expect("no device format available");
    let channels = format.channels;
    std::thread::spawn(move || {
        let stream_id = event_loop.build_input_stream(&device, &format).unwrap();
        let mut meters = (0..format.channels)
            .map(|_| PeakMeter::new(format.sample_rate.0))
            .collect::<SmallVec<[PeakMeter; 16]>>();
        event_loop
            .play_stream(stream_id)
            .expect("failed to start input stream");
        event_loop.run(move |_id, result| {
            let data = match result {
                Ok(data) => data,
                Err(err) => {
                    eprintln!("An error occurred on stream: {:?}", err);
                    return;
                }
            };

            let buffer: Vec<f64> = match data {
                StreamData::Input {
                    buffer: UnknownTypeInputBuffer::U16(buffer),
                } => buffer
                    .iter()
                    .cloned()
                    .map(|v: u16| v.to_f32() as f64)
                    .collect(),
                StreamData::Input {
                    buffer: UnknownTypeInputBuffer::I16(buffer),
                } => buffer
                    .iter()
                    .cloned()
                    .map(|v: i16| v.to_f32() as f64)
                    .collect(),
                StreamData::Input {
                    buffer: UnknownTypeInputBuffer::F32(buffer),
                } => buffer.iter().cloned().map(|v: f32| v as f64).collect(),
                _ => unreachable!(),
            };
            let buffers = group_interleaved_channels(&buffer, format.channels as usize);
            for (buffer, meter) in buffers.into_iter().zip(&mut meters) {
                meter.add_samples(&buffer);
            }
            tx.send(meters.iter_mut().map(|m| m.get_true_peak()).collect())
                .unwrap();
        });
    });

    let mb = MultiBar::new();
    let mut bars = SmallVec::<[_; 16]>::new();

    for i in 0..channels {
        let mut pb = mb.create_bar(100);
        pb.show_percent = false;
        pb.show_counter = false;
        pb.show_speed = false;
        pb.show_tick = false;
        pb.show_time_left = false;
        bars.push(pb);
    }

    std::thread::spawn(move || mb.listen());

    for peaks in rx.into_iter() {
        for (value, pb) in peaks.into_iter().zip(&mut bars) {
            let db: Decibel = value.into();
            pb.set(map(db.0, -48.0, 0.0, 0.0, 100.0).round() as u64);
            pb.message(&format!("{} ", db));
        }
    }
}

fn map(x: f64, min: f64, max: f64, dst_min: f64, dst_max: f64) -> f64 {
    let range = max - min;
    let dst_range = dst_max - dst_min;
    let normalized = (x - min) / range;
    dst_min + normalized * dst_range
}

fn group_interleaved_channels(buffer: &[f64], channels: usize) -> SmallVec<[Vec<f64>; 16]> {
    let mut outer = SmallVec::<[Vec<f64>; 16]>::new();
    for _ in 0..channels {
        outer.push(Vec::with_capacity(buffer.len() / channels));
    }
    for (i, val) in buffer.iter().cloned().enumerate() {
        outer[i % channels].push(val);
    }
    outer
}
