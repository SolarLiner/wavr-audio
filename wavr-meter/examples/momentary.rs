/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use std::sync::mpsc::sync_channel;
use std::time::Duration;

use cpal::traits::{DeviceTrait, EventLoopTrait, HostTrait};
use cpal::{Sample, StreamData, UnknownTypeInputBuffer};
use pbr::{MultiBar, ProgressBar};
use smallvec::SmallVec;

use wavr_meter::decibel::{Decibel, LUFS};
use wavr_meter::ebu::modes::Momentary;
use wavr_meter::EBUMeter;

fn main() {
    let (tx, rx) = sync_channel::<LUFS>(16);
    let host = cpal::default_host();
    let event_loop = host.event_loop();
    let device = host
        .default_input_device()
        .expect("no output device available");
    let format = device
        .default_input_format()
        .expect("no device format available");
    std::thread::spawn(move || {
        let stream_id = event_loop.build_input_stream(&device, &format).unwrap();
        let mut meter = EBUMeter::<Momentary>::new(format.channels as u32, format.sample_rate.0);
        event_loop
            .play_stream(stream_id)
            .expect("failed to start input stream");
        event_loop.run(move |_id, result| {
            let data = match result {
                Ok(data) => data,
                Err(err) => {
                    eprintln!("An error occurred on stream: {:?}", err);
                    return;
                }
            };

            let buffer: Vec<f64> = match data {
                StreamData::Input {
                    buffer: UnknownTypeInputBuffer::U16(buffer),
                } => buffer
                    .iter()
                    .cloned()
                    .map(|v: u16| v.to_f32() as f64)
                    .collect(),
                StreamData::Input {
                    buffer: UnknownTypeInputBuffer::I16(buffer),
                } => buffer
                    .iter()
                    .cloned()
                    .map(|v: i16| v.to_f32() as f64)
                    .collect(),
                StreamData::Input {
                    buffer: UnknownTypeInputBuffer::F32(buffer),
                } => buffer.iter().cloned().map(|v: f32| v as f64).collect(),
                _ => unreachable!(),
            };
            meter.add_samples(&buffer);
            tx.send(meter.get_loudness()).unwrap();
        });
    });

    let mut pb = ProgressBar::new(100);
    pb.show_percent = false;
    pb.show_counter = false;
    pb.show_speed = false;
    pb.show_tick = false;
    pb.show_time_left = false;

    for value in rx.into_iter() {
        let Decibel(db) = value;
        pb.set(map(db, -48.0, 0.0, 0.0, 100.0).round() as u64);
        pb.message(&format!("EBU M: {:.2} LUFS ", db));
    }

    pb.finish_println("Aborted.");
}

fn map(x: f64, min: f64, max: f64, dst_min: f64, dst_max: f64) -> f64 {
    let range = max - min;
    let dst_range = dst_max - dst_min;
    let normalized = (x - min) / range;
    dst_min + normalized * dst_range
}
