/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use std::marker::PhantomData;

use ebur128::EbuR128;

use crate::decibel::{Decibel, LUFS};

pub mod modes {
    use ebur128::{EbuR128, Mode};

    use crate::decibel::{Decibel, LUFS};

    pub trait EBUMeterMode {
        fn mode() -> Mode;
        fn get_loudness(meter: &EbuR128) -> LUFS;
    }

    #[derive(Copy, Clone, Debug)]
    pub struct Momentary;

    #[derive(Copy, Clone, Debug)]
    pub struct Short;

    #[derive(Copy, Clone, Debug)]
    pub struct Integrated;

    impl EBUMeterMode for Momentary {
        fn mode() -> Mode {
            Mode::M
        }

        fn get_loudness(meter: &EbuR128) -> LUFS {
            Decibel(meter.loudness_momentary().unwrap())
        }
    }

    impl EBUMeterMode for Short {
        fn mode() -> Mode {
            Mode::S
        }

        fn get_loudness(meter: &EbuR128) -> LUFS {
            Decibel(meter.loudness_shortterm().unwrap())
        }
    }

    impl EBUMeterMode for Integrated {
        fn mode() -> Mode {
            Mode::I
        }

        fn get_loudness(meter: &EbuR128) -> LUFS {
            Decibel(meter.loudness_global().unwrap())
        }
    }
}

#[derive(Debug)]
pub struct EBUMeter<Mode: modes::EBUMeterMode> {
    meter: EbuR128,
    mode: PhantomData<Mode>,
}

impl<Mode: modes::EBUMeterMode> EBUMeter<Mode> {
    pub fn new(channels: u32, samplerate: u32) -> Self {
        Self {
            mode: PhantomData,
            meter: EbuR128::new(channels, samplerate, Mode::mode()).unwrap(),
        }
    }

    pub fn add_samples(&mut self, buffer: &[f64]) -> bool {
        self.meter.add_frames_f64(buffer).is_ok()
    }

    pub fn get_loudness(&self) -> LUFS {
        Mode::get_loudness(&self.meter)
    }
}

impl EBUMeter<modes::Integrated> {
    pub fn get_range(&self) -> LUFS {
        let raw = self.meter.loudness_range().unwrap();
        Decibel(raw)
    }
}
