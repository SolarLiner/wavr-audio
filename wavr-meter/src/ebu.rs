/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */
//! # The Wavr Meter Audio
//!
//! This crates wraps `libebur128`'s EBU meter with a Rust idiomatic-ish implementation.

use std::marker::PhantomData;

use ebur128::EbuR128;

use crate::decibel::{Decibel, LUFS};

/// EBU modes as flag types.
pub mod modes {
    use ebur128::{EbuR128, Mode};

    use crate::decibel::{Decibel, LUFS};

    /// EBU Mode trait. Used by the flag types to place the calls into `ebur128`.
    pub trait EBUMeterMode {
        // TODO: Change mode to associated const
        /// Return the EBU mode associated with the type.
        fn mode() -> Mode;
        /// Return the loudness from the associated EBU mode.
        fn get_loudness(meter: &EbuR128) -> LUFS;
    }

    /// EBU Momentary (300ms) loudness metering.
    #[derive(Copy, Clone, Debug)]
    pub struct Momentary;

    /// EBU Short-term (1s) loudness metering.
    #[derive(Copy, Clone, Debug)]
    pub struct Short;

    /// EBU Integrated (whole program range) metering.
    #[derive(Copy, Clone, Debug)]
    pub struct Integrated;

    impl EBUMeterMode for Momentary {
        fn mode() -> Mode {
            Mode::M
        }

        fn get_loudness(meter: &EbuR128) -> LUFS {
            Decibel(meter.loudness_momentary().unwrap())
        }
    }

    impl EBUMeterMode for Short {
        fn mode() -> Mode {
            Mode::S
        }

        fn get_loudness(meter: &EbuR128) -> LUFS {
            Decibel(meter.loudness_shortterm().unwrap())
        }
    }

    impl EBUMeterMode for Integrated {
        fn mode() -> Mode {
            Mode::I
        }

        fn get_loudness(meter: &EbuR128) -> LUFS {
            Decibel(meter.loudness_global().unwrap())
        }
    }
}

/// EBU metering structure.
#[derive(Debug)]
pub struct EBUMeter<Mode: modes::EBUMeterMode> {
    meter: EbuR128,
    mode: PhantomData<Mode>,
}

impl<Mode: modes::EBUMeterMode> EBUMeter<Mode> {
    /// New ebu meter with the given channels and sample rate.
    pub fn new(channels: u32, samplerate: u32) -> Self {
        Self {
            mode: PhantomData,
            meter: EbuR128::new(channels, samplerate, Mode::mode()).unwrap(),
        }
    }

    /// Add a frame to process by the loudness meter.
    pub fn add_samples(&mut self, buffer: &[f64]) -> bool {
        self.meter.add_frames_f64(buffer).is_ok()
    }

    /// Returns the computed loudness.
    pub fn get_loudness(&self) -> LUFS {
        Mode::get_loudness(&self.meter)
    }
}

impl EBUMeter<modes::Integrated> {
    /// Get loudness range (only available in Integrated mode).
    pub fn get_range(&self) -> LUFS {
        let raw = self.meter.loudness_range().unwrap();
        Decibel(raw)
    }
}
