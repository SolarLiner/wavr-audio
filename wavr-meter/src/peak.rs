/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use circular_queue::CircularQueue;
use ebur128::EbuR128;

use crate::decibel::Linear;

#[derive(Debug)]
pub struct PeakMeter {
    meter: EbuR128,
    decay: f64,
    peaks: CircularQueue<Linear>,
    last_shown_peak: Linear,
}

impl PeakMeter {
    pub fn new(sample_rate: u32) -> Self {
        Self {
            meter: EbuR128::new(
                1,
                sample_rate,
                ebur128::Mode::SAMPLE_PEAK | ebur128::Mode::TRUE_PEAK,
            )
            .unwrap(),
            peaks: CircularQueue::with_capacity(5),
            last_shown_peak: Linear(0.0),
            decay: 0.96,
        }
    }

    pub fn add_samples(&mut self, buffer: &[f64]) {
        self.meter.add_frames_f64(buffer).unwrap();
    }

    pub fn set_decay(&mut self, decay: f64) {
        self.decay = decay;
    }

    pub fn get_sample_peak(&mut self) -> Linear {
        let val = self.meter.prev_sample_peak(0).unwrap();
        let val = self.get_held_peak(Linear(val));
        let val = if val > self.last_shown_peak {
            val
        } else {
            self.last_shown_peak * self.decay
        };
        self.last_shown_peak = val;
        val
    }

    pub fn get_true_peak(&mut self) -> Linear {
        let val = self.meter.prev_true_peak(0).unwrap();
        let val = self.get_held_peak(Linear(val));
        let val = if val >= self.last_shown_peak {
            val
        } else {
            self.last_shown_peak * self.decay
        };
        self.last_shown_peak = val;
        val
    }

    fn get_held_peak(&mut self, val: Linear) -> Linear {
        self.peaks.push(val);
        *self
            .peaks
            .iter()
            .filter(|a| a.0.is_finite())
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap_or(&val)
    }
}
