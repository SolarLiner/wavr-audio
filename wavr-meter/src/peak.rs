/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */
//! # The Wavr Audio Meter
//!
//! This crates implements a single-channel true peak meter.

use circular_queue::CircularQueue;
use ebur128::EbuR128;

use crate::decibel::Linear;

/// A single-channel peak meter, implemented by `libebur128`'s True Peak mode. The meter also
/// features peak-holding and value decay to stabilize the peak display while staying accurate.
#[derive(Debug)]
pub struct PeakMeter {
    meter: EbuR128,
    decay: f64,
    peaks: CircularQueue<Linear>,
    last_peak: Linear,
}

impl PeakMeter {
    /// Create a new peak meter using the given sample rate.
    pub fn new(sample_rate: u32) -> Self {
        Self {
            meter: EbuR128::new(1, sample_rate, ebur128::Mode::TRUE_PEAK).unwrap(),
            peaks: CircularQueue::with_capacity(10),
            last_peak: Linear(0.0),
            decay: 0.98,
        }
    }

    /// Add a frame to process by the peak meter.
    pub fn add_samples(&mut self, buffer: &[f64]) {
        if let Some(peak) = self.peaks.iter().cloned().next() {
            let peak = self.get_held_peak(peak);
            self.last_peak = if peak >= self.last_peak {
                peak
            } else {
                self.last_peak * self.decay
            };
        }

        self.meter.add_frames_f64(buffer).unwrap();
        self.peaks
            .push(Linear(self.meter.prev_true_peak(0).unwrap()));
    }

    /// Returns the level decay coefficient.
    pub fn decay(&self) -> f64 {
        self.decay
    }

    /// Sets the level decay coefficient.
    pub fn set_decay(&mut self, decay: f64) {
        self.decay = decay;
    }

    /// Gets the true peak value, taking into account peak-holding and level decay.
    pub fn get_true_peak(&self) -> Linear {
        self.last_peak
    }

    fn get_held_peak(&self, val: Linear) -> Linear {
        *self
            .peaks
            .iter()
            .filter(|a| a.0.is_finite())
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap_or(&val)
    }
}
