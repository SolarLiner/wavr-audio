/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use smallvec::{Array, SmallVec};

pub use ebu::*;
pub use peak::*;
use wavr_audio_buffer::AudioBuffer;

use crate::decibel::{Linear, LUFS};

pub mod decibel;
pub mod ebu;
pub mod peak;

#[derive(Debug)]
pub struct WavrMeter {
    channels: u32,
    peak_meters: SmallVec<[PeakMeter; 16]>,
    ebu_meter: EBUMeter<modes::Short>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct WavrMeterData {
    pub peak: SmallVec<[Linear; 16]>,
    pub loudness: LUFS,
}

impl WavrMeter {
    pub fn new(channels: u32, sample_rate: u32) -> Self {
        Self {
            channels,
            peak_meters: (0..channels).map(|_| PeakMeter::new(sample_rate)).collect(),
            ebu_meter: EBUMeter::new(channels, sample_rate),
        }
    }

    pub fn add_samples(&mut self, buffer: &AudioBuffer) {
        let interleaved = AudioBuffer::clone(buffer).interleave();
        self.ebu_meter.add_samples(&interleaved);
        for (buffer, meter) in buffer.iter().zip(&mut self.peak_meters) {
            meter.add_samples(&buffer);
        }
    }

    pub fn get_values(&self) -> WavrMeterData {
        WavrMeterData {
            peak: self.peak_meters.iter().map(|m| m.get_true_peak()).collect(),
            loudness: self.ebu_meter.get_loudness(),
        }
    }
}

pub fn group_interleaved_channels(buffer: &[f64], channels: usize) -> SmallVec<[Vec<f64>; 16]> {
    let mut outer = SmallVec::<[Vec<f64>; 16]>::new();
    for _ in 0..channels {
        outer.push(Vec::with_capacity(buffer.len() / channels));
    }
    for (i, val) in buffer.iter().cloned().enumerate() {
        outer[i % channels].push(val);
    }
    outer
}
