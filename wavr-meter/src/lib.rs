/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */
//! # The Wavr Audio Meter
//!
//! This crate implements a dual-purpose peak and EBU loudness audio metering, using `libebur128`
//! as the backing implementation.

use smallvec::{Array, SmallVec};

pub use ebu::*;
pub use peak::*;
use wavr_audio_buffer::AudioBuffer;

use crate::decibel::{Linear, LUFS};

pub mod decibel;
pub mod ebu;
pub mod peak;

/// Audio meter structure. Holds a peak meter for each channel, and a single EBU meter for the
/// whole input.
#[derive(Debug)]
pub struct WavrMeter {
    channels: u32,
    peak_meters: SmallVec<[PeakMeter; 16]>,
    ebu_meter: EBUMeter<modes::Short>,
}

/// Audio meter data, computed from `WavrMeter`.
#[derive(Clone, Debug, PartialEq)]
pub struct WavrMeterData {
    pub peak: SmallVec<[Linear; 16]>,
    pub loudness: LUFS,
}

impl WavrMeter {
    /// Create a new audio meter from the given channel count and sample rate.
    pub fn new(channels: u32, sample_rate: u32) -> Self {
        Self {
            channels,
            peak_meters: (0..channels).map(|_| PeakMeter::new(sample_rate)).collect(),
            ebu_meter: EBUMeter::new(channels, sample_rate),
        }
    }

    /// Add an audio frame to process by the audio meter.
    pub fn add_samples(&mut self, buffer: &AudioBuffer) {
        let interleaved = AudioBuffer::clone(buffer).interleave();
        self.ebu_meter.add_samples(&interleaved);
        for (buffer, meter) in buffer.iter().zip(&mut self.peak_meters) {
            meter.add_samples(&buffer);
        }
    }

    /// Get the processed audio meter values.
    pub fn get_values(&self) -> WavrMeterData {
        WavrMeterData {
            peak: self.peak_meters.iter().map(|m| m.get_true_peak()).collect(),
            loudness: self.ebu_meter.get_loudness(),
        }
    }
}
