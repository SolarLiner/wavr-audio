/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use smallvec::SmallVec;

pub use ebu::*;
pub use peak::*;

use crate::decibel::{Linear, LUFS};

pub mod decibel;
pub mod ebu;
pub mod peak;

pub struct WavrMeter {
    channels: u32,
    peak_meters: SmallVec<[PeakMeter; 16]>,
    ebu_meter: EBUMeter<modes::Momentary>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct WavrMeterData {
    pub peak: SmallVec<[Linear; 16]>,
    pub loudness: LUFS,
}

impl WavrMeter {
    pub fn new(channels: u32, sample_rate: u32) -> Self {
        Self {
            channels,
            peak_meters: (0..channels).map(|_| PeakMeter::new(sample_rate)).collect(),
            ebu_meter: EBUMeter::new(channels, sample_rate),
        }
    }

    pub fn add_samples(&mut self, buffer: &[f64]) {
        self.ebu_meter.add_samples(buffer);
        let channels = group_interleaved_channels(buffer, self.channels as usize);
        for (buffer, meter) in channels.into_iter().zip(&mut self.peak_meters) {
            meter.add_samples(&buffer);
        }
    }

    pub fn get_values(&mut self) -> WavrMeterData {
        WavrMeterData {
            peak: self
                .peak_meters
                .iter_mut()
                .map(|m| m.get_true_peak())
                .collect(),
            loudness: self.ebu_meter.get_loudness(),
        }
    }
}

pub fn group_interleaved_channels(buffer: &[f64], channels: usize) -> SmallVec<[Vec<f64>; 16]> {
    let mut outer = SmallVec::<[Vec<f64>; 16]>::new();
    for _ in 0..channels {
        outer.push(Vec::with_capacity(buffer.len() / channels));
    }
    for (i, val) in buffer.iter().cloned().enumerate() {
        outer[i % channels].push(val);
    }
    outer
}
