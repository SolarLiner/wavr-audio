/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use std::borrow::Borrow;
use std::cell::{Ref, RefCell};
use std::ops::Deref;
use std::rc::Rc;

use gtk::{Inhibit, StyleContextExt, WidgetExt};
use relm::{connect, interval, DrawHandler, Relm, Update, Widget};
use relm_derive::Msg;

use wavr_meter::decibel::{Decibel, LUFS};

use crate::range::Range;

#[derive(Msg, Clone, Debug)]
pub enum Messages {
    Value(Decibel, LUFS),
    Redraw,
}

pub struct SingleMeterModel {
    peak: Decibel,
    loudness: LUFS,
}

pub struct SingleMeter {
    data: Rc<RefCell<Option<SingleMeterModel>>>,
    root: gtk::DrawingArea,
    range: Range<f64>,

    draw_handler: DrawHandler<gtk::DrawingArea>,
}

impl Update for SingleMeter {
    type Model = Option<SingleMeterModel>;
    type ModelParam = ();
    type Msg = Messages;

    fn model(relm: &Relm<Self>, param: Self::ModelParam) -> Self::Model {
        None
    }

    fn subscriptions(&mut self, _relm: &Relm<Self>) {
        interval(_relm.stream(), 16, || Messages::Redraw);
    }

    fn update(&mut self, event: Self::Msg) {
        match event {
            Messages::Value(peak, loudness) => {
                *self.data.borrow_mut() = Some(SingleMeterModel { peak, loudness });
            }
            Messages::Redraw => {
                self.root.queue_draw();
                /*let ctx = self.draw_handler.get_context();
                let alloc = self.root.get_allocation();
                let width = alloc.width as f64;
                let height = alloc.height as f64;
                let pattern = cairo::LinearGradient::new(0.0, 0.0, 0.0, height);
                let zero_point = 1.0 - self.range.map(0.0);
                let half_point = 1.0 - self.range.map(-6.0);
                pattern.add_color_stop_rgb(0.0, 1.0, 0.2, 0.1);
                pattern.add_color_stop_rgb(zero_point, 1.0, 0.2, 0.1);
                pattern.add_color_stop_rgb(zero_point + 0.001, 1.0, 1.0, 0.2);
                pattern.add_color_stop_rgb(half_point, 1.0, 1.0, 0.2);
                pattern.add_color_stop_rgb(half_point + 0.001, 0.1, 1.0, 0.2);
                pattern.add_color_stop_rgb(1.0, 0.0, 0.7, 0.1);

                ctx.save();
                //ctx.translate(alloc.x as f64, alloc.y as f64);

                ctx.rectangle(0.0, 0.0, width, height);
                ctx.set_source_rgb(0.15, 0.2, 0.2);
                ctx.fill();

                if let Some(data) = &self.data {
                    let peak_pc = self.range.map(data.peak.0);
                    let peak = height * peak_pc;
                    let peak_inv = height * (1.0 - peak_pc);

                    ctx.set_source(&pattern);
                    ctx.rectangle(0.0, peak_inv, width, peak);
                    ctx.fill();

                    let loudness_pc = self.range.map(data.loudness.0);
                    let loudness = height * loudness_pc;
                    let loudness_inv = height * (1.0 - loudness_pc);

                    ctx.set_source_rgba(0.1, 0.5, 1.0, 0.5);
                    ctx.rectangle(0.0, loudness_inv, width, loudness);
                    ctx.fill();

                    ctx.set_source_rgba(0.0, 0.0, 0.0, 0.3);
                    ctx.set_line_width(1.);
                    for y in ((self.range.min as i32)..=0)
                        .step_by(6)
                        .map(|m| (1.0 - self.range.map(m as f64)) * height)
                    {
                        ctx.move_to(0.0, y);
                        ctx.line_to(width, y);
                    }
                    ctx.stroke();

                    ctx.restore();
                }*/
            }
        }
    }
}

impl Widget for SingleMeter {
    type Root = gtk::DrawingArea;

    fn init_view(&mut self) {
        let model = self.data.clone();
        let range = self.range;

        self.root.connect_draw(move |da, cr| {
            let alloc = da.get_allocation();
            let width = alloc.width as f64;
            let height = alloc.height as f64;
            let model: Ref<_> = model.deref().borrow();
            let style = da.get_style_context();
            let pattern = cairo::LinearGradient::new(0.0, 0.0, 0.0, height);
            let zero_point = 1.0 - range.map(0.0);
            let half_point = 1.0 - range.map(-6.0);
            pattern.set_extend(cairo::Extend::Pad);
            pattern.add_color_stop_rgb(0.0, 1.0, 0.2, 0.1);
            pattern.add_color_stop_rgb(zero_point, 1.0, 0.2, 0.1);
            pattern.add_color_stop_rgb(zero_point, 1.0, 1.0, 0.2);
            pattern.add_color_stop_rgb(half_point, 1.0, 1.0, 0.2);
            pattern.add_color_stop_rgb(half_point, 0.1, 1.0, 0.2);
            pattern.add_color_stop_rgb(1.0, 0.0, 0.7, 0.1);

            gtk::render_background(&style, cr, 0.0, 0.0, width, height);
            cr.set_source_rgba(0.0, 0.0, 0.0, 0.1);
            cr.rectangle(0.0, 0.0, width, height);
            cr.fill();

            if let Some(data) = model.deref() {
                let peak_pc = range.map(data.peak.0);
                let peak = height * peak_pc;
                let peak_inv = height * (1.0 - peak_pc);

                cr.set_source(&pattern);
                cr.rectangle(0.0, peak_inv, width, peak);
                cr.fill();

                let loudness_pc = range.map(data.loudness.0);
                let loudness = height * loudness_pc;
                let loudness_inv = height * (1.0 - loudness_pc);

                cr.set_source_rgba(0.1, 0.5, 1.0, 0.7);
                cr.rectangle(0.0, loudness_inv, width, loudness);
                cr.fill();

                cr.set_source_rgba(0.0, 0.0, 0.0, 0.3);
                cr.set_line_width(1.);
                for y in ((range.min as i32)..=0)
                    .step_by(6)
                    .map(|m| (1.0 - range.map(m as f64)) * height)
                {
                    cr.move_to(0.0, y);
                    cr.line_to(width, y);
                }
                cr.stroke();

                cr.set_source_rgb(0.0, 0.0, 0.0);
                for (dB, y) in ((range.min as i32)..=0)
                    .step_by(6)
                    .map(|m| (m, height * (1.0 - range.map(m as f64))))
                {
                    let text = format!("{}", dB);
                    let extends = cr.text_extents(&text);
                    cr.move_to(2.0, extends.height + y + 2.0);
                    cr.text_path(&text);
                }
                cr.fill();
            }
            Inhibit(false)
        });
    }

    fn root(&self) -> Self::Root {
        self.root.clone()
    }

    fn view(relm: &Relm<Self>, data: Option<SingleMeterModel>) -> Self {
        let root = gtk::DrawingAreaBuilder::new()
            .vexpand(true)
            .hexpand(true)
            .width_request(2)
            .height_request(100)
            .build();
        Self {
            data: Rc::from(RefCell::from(data)),
            range: Range {
                min: -48.0,
                max: 6.0,
            },
            draw_handler: DrawHandler::new().unwrap(),
            root,
        }
    }
}
