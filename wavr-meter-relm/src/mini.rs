/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */

use std::cell::RefCell;
use std::ops::{Deref, DerefMut};
use std::rc::Rc;

use gtk::{Inhibit, StyleContextExt, WidgetExt};
use relm::{interval, DrawHandler, Relm, Update, Widget};
use relm_derive::Msg;

use wavr_meter::decibel::{Decibel, Linear};

use crate::range::Range;

#[derive(Msg, Clone, Debug)]
pub enum Messages {
    Peak(Linear),
    Redraw,
}

#[derive(Copy, Clone, Debug)]
pub struct MiniMeterModel {
    peak: Decibel,
    led_width: u32,
    range: Range<f64>,
}

pub struct MiniMeter {
    root: gtk::DrawingArea,
    handler: DrawHandler<gtk::DrawingArea>,
    model: Rc<RefCell<MiniMeterModel>>,
}

impl MiniMeterModel {
    fn draw_tick(cr: &cairo::Context, x: f64, width: f64, height: f64) {
        cr.rectangle(x, 0.0, width, height);
        cr.fill();
    }

    fn draw_ticks(&self, cr: &cairo::Context, width: f64, height: f64) {
        let peak_pc = self.range.map(self.peak.0);
        let leds = width as u32 / (self.led_width + 3);
        dbg!(leds);
        for i in 0..leds {
            let pc = i as f64 / leds as f64;
            if peak_pc > pc {
                self.set_tick_color(cr, self.range.unmap(pc));
                Self::draw_tick(cr, pc * width, self.led_width as f64, height);
            }
        }
    }

    fn set_tick_color(&self, cr: &cairo::Context, led_peak_value: f64) {
        if led_peak_value >= 0.0 {
            cr.set_source_rgb(1.0, 0.1, 0.2);
        } else if led_peak_value >= -6.0 {
            cr.set_source_rgb(1.0, 1.0, 0.2);
        } else {
            cr.set_source_rgb(0.1, 1.0, 0.2);
        }
    }
}

impl Update for MiniMeter {
    type Model = MiniMeterModel;
    type ModelParam = ();
    type Msg = Messages;

    fn model(_: &Relm<Self>, _: Self::ModelParam) -> Self::Model {
        MiniMeterModel {
            peak: Linear(0.).into(),
            led_width: 2,
            range: Range {
                min: -30.0,
                max: 6.0,
            },
        }
    }

    fn subscriptions(&mut self, relm: &Relm<Self>) {
        interval(relm.stream(), 16, || Messages::Redraw);
    }

    fn update(&mut self, event: Self::Msg) {
        match event {
            Messages::Peak(val) => self.model.borrow_mut().peak = val.into(),
            Messages::Redraw => {
                /*let ctx = self.handler.get_context();
                let style = self.root.get_style_context();
                let alloc = self.root.get_allocation();
                let width = alloc.width as f64;
                let height = alloc.height as f64;
                let peak_pc = self.model.range.map(self.model.peak.0);
                println!("Allocation: {} x {}", width, height);

                gtk::render_background(&style, &ctx, 0.0, 0.0, width, height);

                ctx.set_source_rgb(1.0, 0.5, 1.0);
                ctx.rectangle(peak_pc * width, 10.0, 10.0, 10.0);
                ctx.fill();*/
                self.root.queue_draw();
            }
        }
    }
}

impl Widget for MiniMeter {
    type Root = gtk::DrawingArea;

    fn init_view(&mut self) {
        //self.handler.init(&self.root);
        let model = self.model.clone();
        self.root.connect_draw(move |da, cr| {
            let style = da.get_style_context();
            let alloc = da.get_allocation();
            let width = alloc.width as f64;
            let height = alloc.height as f64;
            let model = model.borrow();

            gtk::render_background(&style, &cr, 0.0, 0.0, width, height);

            model.draw_ticks(cr, width, height);

            Inhibit(false)
        });
    }

    fn root(&self) -> Self::Root {
        self.root.clone()
    }

    fn view(relm: &Relm<Self>, model: MiniMeterModel) -> Self {
        let root = gtk::DrawingAreaBuilder::new()
            .hexpand(true)
            .width_request(100)
            .height_request(10)
            .build();
        let handler = DrawHandler::new().unwrap();

        Self {
            root,
            handler,
            model: Rc::from(RefCell::from(model)),
        }
    }
}
