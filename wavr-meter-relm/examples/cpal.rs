/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */
use cpal::traits::{DeviceTrait, HostTrait};
use cpal::{default_host, StreamError};
use relm::{Component, ContainerWidget, Relm, Update, Widget};
use std::sync::mpsc::{sync_channel, Receiver};
use std::thread::JoinHandle;
use wavr_meter::{WavrMeter, WavrMeterData};
use wavr_meter_relm::{Messages as WidgetMessages, WavrMeterWidget};

pub struct App {
    root: gtk::Window,
    meter: Component<WavrMeterWidget>,
    msg_thread: JoinHandle<()>,
}

impl Update for App {
    type Model = JoinHandle<()>;
    type ModelParam = (u16, Receiver<WavrMeterData>);
    type Msg = WidgetMessages;

    fn model(relm: &Relm<Self>, (channel_count, rx): Self::ModelParam) -> Self::Model {
        let stream = relm.stream().clone();
        std::thread::spawn(move || {
            stream.emit(WidgetMessages::Setup(channel_count));
            for data in rx.into_iter() {
                stream.emit(WidgetMessages::Value(data));
            }
        })
    }

    fn update(&mut self, event: Self::Msg) {
        self.meter.emit(event);
    }
}

impl Widget for App {
    type Root = gtk::Window;

    fn root(&self) -> Self::Root {
        self.root.clone()
    }

    fn view(relm: &Relm<Self>, msg_thread: JoinHandle<()>) -> Self {
        let root = gtk::WindowBuilder::new()
            .margin(10)
            .title("Wavr Meter")
            .build();
        let meter = root.add_widget::<WavrMeterWidget>(());
        Self {
            root,
            meter,
            msg_thread,
        }
    }
}

fn main() {
    let host = default_host();
    let event_loop = host.event_loop();
    let device = host.default_input_device().unwrap();
    let config = device.default_input_config().unwrap().config();
    let channel_count = config.channels;
    let mut meter = WavrMeter::new(config.channels as u32, config.sample_rate.0);
    let (tx, rx) = sync_channel(16);
    let stream = device
        .build_input_stream(
            &config,
            move |data, output_cb_info| {
                meter.add_samples(data);
                tx(meter.get_values());
            },
            move |err| {},
        )
        .unwrap();

    let app = App::run((channel_count, rx)).unwrap();
}

fn error_fn(err: StreamError) {
    eprintln!("An error occured in the audio thread: {:?}", err);
}
