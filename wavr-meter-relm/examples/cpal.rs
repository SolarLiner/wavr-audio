/*
 * Copyright (c) 2020 the Wavr Audio project.
 * This source file, as well as the binaries generated by it,
 * are licensed under MIT.
 */
use std::marker::PhantomData;
use std::sync::mpsc::{sync_channel, Receiver, SyncSender};
use std::thread::JoinHandle;

use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use cpal::{
    default_host, BuildStreamError, Device, Sample, SampleFormat, SampleRate, Stream, StreamConfig,
    StreamError,
};
use gtk::{ContainerExt, WidgetExt};
use num::ToPrimitive;
use relm::{connect, Channel, Component, ContainerWidget, Relm, Sender, Update, Widget};
use relm_derive::Msg;

use wavr_audio_buffer::AudioBuffer;
use wavr_meter::decibel::Linear;
use wavr_meter::{WavrMeter, WavrMeterData};
use wavr_meter_relm::mini::MiniMeter;
use wavr_meter_relm::{mini, Messages as WidgetMessages, WavrMeterWidget};

#[derive(Msg, Clone, Debug)]
enum AppMessages {
    MeterMessage(WidgetMessages),
    Quit,
}

struct App {
    root: gtk::Window,
    thebox: gtk::Box,
    meter: Component<WavrMeterWidget>,
    minimeter: Component<MiniMeter>,
    channel: Channel<AppMessages>,
    stream: cpal::Stream,
}

impl Update for App {
    type Model = (Channel<AppMessages>, cpal::Stream);
    type ModelParam = (cpal::Device, cpal::SupportedStreamConfig);
    type Msg = AppMessages;

    fn model(relm: &Relm<Self>, (device, stream_config): Self::ModelParam) -> Self::Model {
        let (channel, sender) = Channel::new({
            let stream = relm.stream().clone();
            move |msg| stream.emit(msg)
        });
        let config = stream_config.config();
        let stream = match stream_config.sample_format() {
            SampleFormat::U16 => build_stream::<u16>(device, &config, sender),
            SampleFormat::I16 => build_stream::<i16>(device, &config, sender),
            SampleFormat::F32 => build_stream::<f32>(device, &config, sender),
        }
        .unwrap();
        relm.stream()
            .emit(AppMessages::MeterMessage(WidgetMessages::Setup(
                config.channels,
            )));
        stream.play().unwrap();
        (channel, stream)
    }

    fn update(&mut self, event: Self::Msg) {
        match event {
            AppMessages::Quit => gtk::main_quit(),
            AppMessages::MeterMessage(event) => {
                self.meter.emit(event.clone());
                if let WidgetMessages::Value(data) = event {
                    let peak = data
                        .peak
                        .iter()
                        .cloned()
                        .filter(|a| a.0.is_finite())
                        .max_by(|a, b| a.partial_cmp(b).unwrap())
                        .unwrap_or(Linear(0.0));
                    self.minimeter.emit(mini::Messages::Peak(peak.into()));
                }
            }
        }
    }
}

fn error_fn(err: cpal::StreamError) {
    eprintln!("An error occurred on the audio thread: {:?}", err);
}

impl Widget for App {
    type Root = gtk::Window;

    fn init_view(&mut self) {
        self.root.show_all();
    }

    fn root(&self) -> Self::Root {
        self.root.clone()
    }

    fn view(relm: &Relm<Self>, (channel, stream): Self::Model) -> Self {
        let root = gtk::WindowBuilder::new()
            .border_width(8)
            .title("Wavr Meter")
            .build();
        connect!(
            relm,
            root,
            connect_delete_event(_, _),
            return (Some(AppMessages::Quit), gtk::Inhibit(false))
        );
        let thebox = gtk::BoxBuilder::new()
            .orientation(gtk::Orientation::Vertical)
            .spacing(8)
            .hexpand(true)
            .vexpand(true)
            .build();
        let meter = thebox.add_widget::<WavrMeterWidget>(());
        let minimeter = thebox.add_widget::<MiniMeter>(());
        root.add(&thebox);
        Self {
            root,
            thebox,
            meter,
            minimeter,
            stream,
            channel,
        }
    }
}

fn main() {
    let host = default_host();
    let device = host.default_input_device().unwrap();
    let stream_config = device.default_input_config().unwrap();
    relm::run::<App>((device, stream_config)).unwrap();
}

fn build_stream<S: cpal::Sample>(
    device: cpal::Device,
    config: &cpal::StreamConfig,
    sender: Sender<AppMessages>,
) -> Result<Stream, BuildStreamError> {
    let mut meter = WavrMeter::new(config.channels as u32, config.sample_rate.0);
    let channels = config.channels as usize;
    device.build_input_stream::<S, _, _>(
        &config,
        move |data, _| {
            let buf = data.iter().map(|v| v.to_f32() as f64).collect::<Vec<_>>();
            let buffer = AudioBuffer::new(channels, &buf);
            meter.add_samples(&buffer);
            sender
                .send(AppMessages::MeterMessage(WidgetMessages::Value(
                    meter.get_values(),
                )))
                .unwrap();
        },
        error_fn,
    )
}
